---
title: "IC2S2 '25 Worksheet"
author: Matt Turner
bibliography: ic2s2-2025.bib
---

```{r}
#| setup: true
#| output: false
#| echo: false
library(socmod)
library(igraph)
library(ggplot2)
```

This worksheet has problem sets and guidance for developing models of social diffusion for use in designing sustainability interventions from empirically-motivated first principles of social cognition and social processes.

## Outline

1.  Installation
2.  Fundamentals of agent-based modeling in R
3.  Agent-based models of adaptation diffusion
4.  Classes in R ([R6 docs](https://r6.r-lib.org/articles/Introduction.html),\
    [R6 Chapter in Hadley Wickham's *Advanced R*](https://adv-r.hadley.nz/r6.html))
5.  Adaptive social learning: success-biased and conformity/frequency-biased learning
6.  Cooperative conservation

## Installation

First, install [R and RStudio](https://rstudio-education.github.io/hopr/starting.html).

Then install `socmod` from GitHub like so

```{r}
#| output: false
# devtools::install_github("css4s/socmod")
```

Not you do not need to have `git` installed to use this command since it just downloads the code from github.

## Fundamentals of agent-based modeling in R

Agent-based modeling is useful because one needs only to specify how agents interact with one another, and how their environment changes, to fully specify a social agent-based model of behavior diffusion. There are some tools in R that make this much easier, and on which my `socmod` library is based.

First, there's R6, which provides an API for defining custom classes, e.g., to define how Agent, Model, and other socmod API components work. For example, one must specify what *attributes* agents have, what *processes* they are capable of, and how their attributes affect their choices. Agents are *autonomous*. They make their own decisions based on what they learn from experience and from social observation or learning.

R6 classes have *fields*, which can be used to represent attributes, and *methods*, which are functions or behaviors that instances of the class can do. For example, the Agent class provided by `socmod` has fields representing its behavior and its *fitness*, which is an abstraction for apparent wealth, skills, happiness, or other features that could make the person an attractive teacher.

See the [Computational Techniques for Agent-based Modeling section of the Tutorial Notes Intro](https://css4s.github.io/IC2S2-Tutorial/intro.html#computational-techniques-for-agent-based-modeling) for some demonstrations of **functional programming** and **defining custom classes in R**, as well as helpful notes on data collections in R. We make extensive use of functional programming in agent-based modeling because we provide *rules* in the form of software *functions* that exist independently of models or agents. It is not just `socmod` that uses functional programming. NetLogo, one of if not the most widely used open source agent-based modeling software packages is essentially a functional programming language that evolved from other functional programming languages from some decades ago.

### Live coding example: functional programming

```{r}

library(purrr)


vec <- c(1, 2, 3, 4)

map(vec, function(x) { return (0.5 * x) })
```

```{r}
map_vec(vec, \(x) x * 0.5)
```

```{r}
map_vec(vec, ~ .x * 0.5)
```

####  Initialize agents with functional programming...

```{r}
library(socmod)

# Initialize one agent
a1 <- Agent$new(1)
print(a1)
```

```{r}

f_A = 1.2
f_L = 1.0
N = 10
create_agent <- function(id) {
  if (runif(1) < 0.2) {
    ret_agent <- Agent$new(id, fitness = f_A, behavior = "Adaptive")  
  } else {
    ret_agent <- Agent$new(id, fitness = f_L, behavior = "Legacy")
  }
  
  return (ret_agent)
}

agents <- map(1:N, create_agent)

length(agents)

behaviors <- map_vec(agents, ~ .x$get_behavior())
table(behaviors)
```

###  Live coding example: our own custom class

```{r}

library(R6)

Cat <- R6Class(
  "Cat", 
  public = list(
    indoor = TRUE,
    color = "Brown",
    yawn = function() {
      print("Meeaauuuuwwn")
    },
    sleeps_a_lot = TRUE,
    
    initialize = function(indoor = TRUE, color = "Brown", sleeps_a_lot = TRUE) {
      self$indoor = indoor
      self$color = color
      self$sleeps_a_lot = sleeps_a_lot
      self$yawn()
    },
    
    live_one_day = function() {
      if (self$sleeps_a_lot) {
        for (ii in 1:10) {
          self$yawn()
        }
      } else {
        for (ii in 1:4) {
          self$yawn()
        }
      }
    }
  )
)
```

With the Cat class defined, let's create two cats, a sleepy and not sleepy one

```{r}
sleepy <- Cat$new()
sleepy$live_one_day()
```

```{r}
not_sleepy <- Cat$new(sleeps_a_lot = FALSE)
not_sleepy$live_one_day()
```

### Exercise:

Create a set of custom class to represent something related to your research, your hobbies, etc. For another example beyond the football one, one student in my course this year created a `Forest` class that had a `trees` field, which was an R list of instances of another class called `Tree`. A `Forest` could track recent rainfall or the spread of pests like the pine bark beetle that loves to infest dried out trees in western North America, exacerbating the risk of catastrophic wildfires due to frequent droughts. Feel free to make your own version of the Tree and Forest classes, or extend the \[football example from the Notes\]().

## Agent-based diffusion model

Before diving in to details, let's see agent-based contagion diffusion in action. Note that success-biased learning is used by default, so we'll implicitly use that for this second example.

First, let's follow the [Agent-based models of social behavior](https://css4s.github.io/IC2S2-Tutorial/intro.html#agent-based-models-of-social-behavior) example from the Introduction of the notes.

```{r}
# Create an example agent-based model with success-biased learning...
abm <- 
  make_abm(graph = make_regular_lattice(10, 4)) %>%
  # Initialize 20% (2) agents with Adaptive behavior w/ 
  # adaptive fitness 1.125x the non-adaptive Legacy behavior
  initialize_agents(initial_prevalence = 0.2, adaptive_fitness = 1.125)

# Inspect the initialization to ensure 2 agents do Adaptive
p <- plot_network_adoption(
  abm, layout = igraph::in_circle(), 
  plot_mod = \(p) p + ggtitle("Adoption at t = 0"), edgewidth = 0.75
)
print(p)
```

```{r}
# Run and visualize a single trial, add title with f_A
p_prevalence <- 
  make_abm(graph = make_regular_lattice(20, 4)) %>%
  initialize_agents(initial_prevalence = 0.2, 
                    adaptive_fitness = 1.125) %>%
  run_trial %>%
  plot_prevalence(tracked_behaviors = c("Adaptive")) %>% 
  { . + ggplot2::ggtitle("Adaptive fitness = 1.125") }

print(p_prevalence)
```

```{r}
g <- igraph::make_graph(~ 1-2, 1-3, 1-4, 3-2)
# mps <- make_model_parameters(graph = g, adaptive_fitness = 1.8, drop_rate = 0.1
# )
cabm <- make_abm(n_agents = 10); 
cabm$get_agent(2)$set_behavior("Adaptive"); 
cabm$get_agent(2)$set_fitness(1.8); 
trial <- run_trial(cabm, stop = fixated)
plot_prevalence(trial, tracked_behaviors = c("Adaptive", "Legacy"))
```

### Run several trials across parameters

```{r}
# Model generator
abm_gen <- function(params) {
  do.call(make_abm, params) %>%
    initialize_agents(
      initial_prevalence = params$initial_prevalence,
      adaptive_fitness = params$adaptive_fitness
    )
}
```

```{r}
# Run five trials per parameter setting, i.e., for each specified adaptive_fitness
adaptive_fitness_vals <- c(0.9, 1.1, 1.4)
trials <-
  run_trials(
    abm_gen,
    n_trials_per_param = 5,
    stop = socmod::fixated,
    n_agents = 20,
    initial_prevalence = 0.1,
    adaptive_fitness = adaptive_fitness_vals
  )
length(trials)
# Summarize within trials only; rename and factor adaptive fitness for display
summary <- summarise_prevalence(
  trials, input_parameters = "adaptive_fitness", across_trials = F
) %>% 
  dplyr::mutate(
    `Adaptive fitness` = factor(adaptive_fitness, adaptive_fitness_vals)
  )

p <- ggplot(
  summary,
  aes(x=Step, y=Prevalence,
      color=`Adaptive fitness`,
      linetype=`Adaptive fitness`,
      group = trial_id)) +
  geom_line(linewidth=1.4, alpha = 0.875) + theme_classic(base_size = 16) +
  ggplot2::scale_color_manual(values = unname(SOCMOD_PALETTE))

print(p)
```

\

```{r}
# Run five trials per parameter setting, i.e., for each specified adaptive_fitness
adaptive_fitness_vals <- c(0.8, 1.0, 1.2, 1.4)
trials <-
  run_trials(
    abm_gen,
    n_trials_per_param = 5,
    stop = socmod::fixated,
    syncfile = "demo-experiment.RData",
    n_agents = 20,
    .progress = T,
    overwrite = T,
    initial_prevalence = 0.1,
    adaptive_fitness = adaptive_fitness_vals
  )
```

We ran five trials for each of the four adaptive fitness values. Then we should have $5 \times 4 = 20$ trials total. Let's check.

```{r}
length(trials)
```

YAY.\
\
Now let's plot the results. We're aiming for the \[outcomes figure in the `socmod` doc\](<https://css4s.github.io/socmod/#example-2b-success-rate-and-average-fixation-time-across-adaptive-fitness>), but we have many less trials than I used there, since it will take too long to run that many for this tutorial.

```{r}
outcomes <- summarise_outcomes(
  trials, 
  input_parameters = "adaptive_fitness", 
  outcome_measures = c("success_rate", "mean_fixation_steps")
) 

max_fix_time <- max(outcomes$Value[outcomes$Measure == "mean_fixation_steps"])
# Normalize to calculate mean fixation time as a fraction of maximum
outcomes_norm <- outcomes %>%
  dplyr::mutate(Value = dplyr::case_when(
    Measure == "mean_fixation_steps" ~ Value / max_fix_time,
    TRUE ~ Value
  ))
# Rename and set order of Measure factors to avoid messing with the legend in plotting
outcomes_norm$Measure[outcomes_norm$Measure == "success_rate"] <- "Success rate"
outcomes_norm$Measure[outcomes_norm$Measure == "mean_fixation_steps"] <- "Normalized fixation time"
outcomes_norm$Measure <- factor(outcomes_norm$Measure, levels = c(
  "Success rate", "Normalized fixation time"
))

# Use a custom socmod line color
line_color <- SOCMOD_PALETTE_CVD["pink"]
outcomes_norm %>%
  ggplot2::ggplot(aes(x = adaptive_fitness, y = Value, linetype = Measure)) +
  geom_line(color = line_color, linewidth=1.5) + 
  scale_x_continuous(breaks = adaptive_fitness_vals) +
  theme_classic(base_size = 16) + xlab("Adaptive fitness") + ylab("Value")
```

## Exercise: contagion and frequency-biased learning

`socmod` provides contagion and frequency-biased learning strategies. In the first example above we assumed agents learned via contagion learning. Then for our computational experiment example we switched to success-biased learning. For this exercise, try recreating the experiment above but use contagion and systematically vary adoption rate.

## Cooperative conservation

In the [chapter on cooperative conservation](https://css4s.github.io/IC2S2-Tutorial/cooperation.html), I develop both a geometric game theory analysis and agent-based model of the evolution of cooperation on a spatial grid. This has applications to conservation problems where cooperation on a spatial grid is essential, as in groundwater conservation in the California Central Valley and other government-managed watersheds.

We will work through that chapter together. There are several exercises there that you could choose from if you want to gain experience with spatial agent-based modeling for conservation.

## More exercises

1.  In this exercise I invite you to examine, critique, or reimagine some work I've begun to predict how many men must choose to follow women in order to break old norms that socially or economically sanctioned men who were observed to be following women. You can find this work at <https://github.com/CSS4S/gender-role-inversion>.\
    \
    This work has been inspried by the work of computational social scientist and philosopher of science Prof. Cailin O'Connor, at University of California, Irvine. She has demonstrated that inequality and unfairness can persist even if the conditions are removed that initially caused the inequality [@OConnor2019Origins], and that minority groups can find themselves especially at risk for suffering inequality [@Mohseni2021]. For example, even though the gender wage gap is closing, professional women often find themselves burdened with an unreasonable amount of domestic chores, even when they are the primary breadwinner [@OConnor2019-magazine].
